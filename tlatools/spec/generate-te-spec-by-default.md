# Generating Trace Expression Specs by Default

## Overview

This document describes & motivates a feature to have TLC generate a trace expression (TE) spec by default, instead of by request via command line parameter.

## Motivation

Trace exploration is an important and much-used feature of the TLA+ Toolbox.
When TLC model-checks a spec and finds an invariant violation, it produces a sequence of states from the initial state to the state violating the invariant.
Invariant violation is usually undesirable and stems from either a failure of system design or of the writing of a formal spec describing that design; thus it is useful to provide the user tools to assist in debugging why the invariant was violated.
Trace exploration is foremost among these, where the user can define additional expressions to be evaluated in each state or transition of the error trace.
This is a nice way to quickly iterate and explore system behavior at greater depth without having to re-run the entire model.

Since trace exploration is such a useful feature, all TLA+ users should have access - not just those who use the toolbox.
The TLA+ Visual Studio Code extension has seen uptake and lacks support for trace exploration.
Adding trace exploration support to the VS Code extension is the ultimate motivator for the work outlined in this spec.

## Design

VS Code development revolves around a user-customizable text editor and high-quality command line tools.
Thus bringing a high-quality trace exploration experience to VS Code really reduces to bringing that experience to the TLC command line interface.
The idea is as follows: when TLC finds an invariant violation, it generates a minimal TLA+ spec which - if itself model-checked by TLC - produces the exact same error trace as leads to the original invariant violation.
Trace exploration is facilitated by alias expressions - a transformation function applied to each state, added to the generated TLA+ spec by the user.
The user can rename variables, hide variables, or add new variables evaluating to an expression of their choice.
When TLC is run on the generated spec it will output an error trace transformed by the alias expression.
All of this work was complete at the start of this project, triggered by providing the `-generateSpecTE` flag to TLC on startup.

It was decided that TLC should generate these TE specs by default, so users would still be able to run trace exploration if they forgot the `-generateSpecTE` flag.
However, there was a problem: the existing method of generating TE specs parsed the actual command line output of TLC, rather than reading the error trace from internal data structures.
This required TLC be run in "tool" mode, where its output was extensively annotated to ease consumption by automated tools; for example:

```
@!@!@STARTMSG 2262:0 @!@!@
TLC2 Version 2.15 of Day Month 20?? (rev: ${git.shortRevision})
@!@!@ENDMSG 2262 @!@!@
@!@!@STARTMSG 2401:3 @!@!@
Please run the Java VM, which executes TLC with a throughput optimized garbage 
collector, by passing the "-XX:+UseParallelGC" property.
@!@!@ENDMSG 2401 @!@!@
```

Running TLC in this mode all the time would be unacceptable.
Furthermore, the text-output-based generation method ran afoul of one its most closely-associated features: alias expressions!
If a user had an alias expression transforming output in their *original* spec, the TE spec was generated from that transformed error trace output and thus nearly guaranteed to be invalid.
Thus the TE spec generation process needed to be rewritten to read from internal TLC data structures, rather than the final command line output.
This was the bulk of development work required for this phase of the project.

## Implementation

The work to generate TE specs from internal TLC data structures is now complete.
TLC behaves as follows:

 * The `-generateSpecTE` flag is ignored; a no-op
 * Users can use the `-noGenerateSpecTE` flag to skip TE spec generation
 * Users can use the `-teSpecOutDir` flag to specify TE spec output directory

The TE spec is generated by default whenever users run TLC, and TLC uses regular human-readable non-tool output.

These changes were implemented by hooking into the `tlc2.output.MP` class, through which all TLC output flows.
An object subscribed to the `MP` class can filter through messages, each associated with an error code.
A handful of error codes are associated with error traces, and a huge amount of detail is present about each state in the trace at this level of the code.
This data was extracted and fed into the TE spec generation code, short-circuiting the original loop.

